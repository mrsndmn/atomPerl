TYPEMAP
MATRIX*		T_AVREF

INPUT
T_AVREF
	{
		if (!SvOK($arg) || !SvROK($arg)) croak(\"Ref?\");
		AV *tm__p = (AV*)SvRV($arg);

		if (SvTYPE(tm__p)!=SVt_PVAV) croak(\"Not ARRAY\");
		AV* tm_p = (AV*)tm__p;
		
		$type m = malloc(sizeof(MATRIX));

		SV **first =  av_fetch (tm_p, 0, 0);
		// sv_dump(tm_p);
		if ( ! ( SvOK(*first) && SvROK(*first) && SvTYPE(SvRV(*first)) == SVt_PVAV ) ) croak(\"arg must be arref of arref111\");
		
		AV *inner = (AV*)SvRV(*first);
		
		int heigth = av_len(tm_p); // av_len is not length but last index!!!
		int width = av_len(inner);

		m->heigth = heigth+1;
		m->width = width+1;
		// printf(\"h: %d \\nw: %d\\n\",m->heigth, m->width);
		m->cell = (int**)malloc(heigth * sizeof(int*));

		for (int i =0; i <= heigth; ++i) {
			SV **_next =  av_fetch (tm_p, i, 0);
			if ( ! (SvOK(*_next) && SvROK(*_next) && SvTYPE(SvRV(*_next)) == SVt_PVAV ) ) croak(\"arg must be arref of arref\");
			AV *next = (AV*)SvRV(*_next);
			if (av_len(next) != width) croak(\"matrix must be rectangular \", av_len(next),\" \", width);

			m->cell[i] = (int*)malloc(width * sizeof(int));
			
			for (int j = 0; j <= width; ++j) {
				SV **_value =  av_fetch (next, j, 0);
				if(!SvOK(*_value)) croak(\"cant fill the matrix\");
				m->cell[i][j] = SvIV(*_value);
				// printf(\"%d \", m->cell[i][j]);
			}
			// printf(\"\\n\");
		}
		$var = ($type)m;
	}


OUTPUT
T_AVREF
	{	
		//sdsdsdasdas
		sv_dump($arg); // $ntt $ntype
		if (!SvOK($arg) || !SvROK($arg)) croak(\"Ref?\");
		$type M = ($type)SvRV($arg);
		// printf(\"%d\", M->width);
		croak (\"catched!!\");// $var $arg $type
		
		// for(unsigned i = 0; i < ; ++i) {
		// 	/* code */
		// }
		

	}	

